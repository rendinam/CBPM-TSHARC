/*!-----------------------------------------------------------------------+
* File         :  cbpm_rw_raw_data.c                                      |
*                                                                         |
* Description  :  Writes a data file with raw button values and positions |
*                                                                         |
* Arguments    :  -Flag to determine if the external index counter gets   |
*                    incremented during the function call.                |
*                                                                         |
* Author       :  M. Rendina                                              |
*-------------------------------------------------------------------------+*/

#include "cbpm_includes.h"


// max number of bytes to get at once via socket communication
#define MAXDATASIZE 300

#define CBI_DATA_BLOCK_START     "--BEGIN DATA--\n"


int cbpm_rw_raw_data(FILE *fp, int mode, int iidx) {

  char *func_name = (char *)__FUNCTION__;
  int debug_level = CTL_System.debug_verbosity;

  int card, datcnt = 0;
  int bunch, turn;
  int i, status;

  float dim_x;  // Dimension in mm
  float dim_y;  // Dimension in mm

  int    TI,  BI,  BO,  TO, phase_word;
  float cTI, cBI, cBO, cTO;
  float Xpos, Xnum;
  float Ypos, Ynum;
  float sum;

  CBPM_DATA  *dp;
  dp = CTL_System.p_Module[iidx]->dsp_data;

  CBPM_CONTROL *cp;
  cp = CTL_System.p_Module[iidx]->control;

  dim_x = cp->detector.horz_coeff;
  dim_y = cp->detector.vert_coeff;

  
  int tblock, ttblock, chan = 0;
  int gsetting;

  // Compose timing block list
  int tblock_list[CBPM_MAX_BUNCHES];
  compose_tblock_list( dp->cbpm_cmd_params.rot_bunch_pat, tblock_list );
  
  int block_bunch_tally[CBPM_MAX_CHANS_PER_CARD];
  // Initialize these
  for (i = 0; i < CBPM_MAX_CHANS_PER_CARD; i++) {
    block_bunch_tally[i] = 0;
  }

  int block0_bunches, block1_bunches;

  block0_bunches  = dp->cbpm_raw_data_header.num_bunches[0];
  block1_bunches  = dp->cbpm_raw_data_header.num_bunches[1];

  int nturns      = dp->cbpm_cmd_params.num_turns;

  int tot_bunches = dp->cbpm_raw_data_header.tot_bunches;



  // Number of words to skip with a static ADC buffer offset to account for
  // reading out data generated by a wrapped bunch pattern.
  // See doc memo: "Bunch_pattern_wrapping_data_readout_method"
  //  This only matters in 14ns mode, where species are interleaved
  // on the timing blocks.
  int block0_wrap_words = dp->cbpm_raw_data_header.num_BP_bits_wrapped[0];
  int block1_wrap_words = dp->cbpm_raw_data_header.num_BP_bits_wrapped[1];


  RDV3_INST_DATA hdata;
  cbpm_prep_instrument_header( &hdata, iidx);
  cbpmfio_rw_instrument_header(fp, mode);


  int (*p_W)()  = NULL;
  int (*p_RW)() = NULL;

  fio_addrs addrs;
  addrs[0] = (long)&(tblock);
  addrs[1] = (long)&(phase_word);
  addrs[2] = (long)&(TI);
  addrs[3] = (long)&(BI);
  addrs[4] = (long)&(BO);
  addrs[5] = (long)&(TO);
  cbpmfio_map_addresses_to_field(&RDV3_raw_data_spec, 0, addrs);


  int count;
  int fio_mode;

  if (mode == WRITE) {

    fio_mode = CBPMFIO_WRITE;
    
  } else { // READ

    fio_mode = CBPMFIO_READ;

    tot_bunches =   CTL_System.meas_info.num_bunches;
    nturns      = *(CTL_System.meas_info.p_num_turns);

  }

  if (debug_level >= CBI_DEBUG_LEVEL_4) {
    printf("num turns:  %d,  CH0_bunches: %d,  CH1_bunches: %d,  total bunches: %d\n",
	   nturns, block0_bunches, block1_bunches, tot_bunches);
  }


  cbpmfio_rw_file_section(fp, fio_mode, num_RDV3_raw_data_label_specs, (CBPMFIO_FIELD_SPEC*)&(RDV3_raw_data_label_specs));
  

  count = 0;

  for (bunch = 0; bunch < tot_bunches; bunch++) {

    for (turn = 0; turn < nturns; turn++) {
      
      if (mode == WRITE) {
	// For each bunch in the pattern, its parity will determine which buffer set to use
	// when extracting the data.
	if (tblock_list[bunch] == 0) {
	  tblock = 0;
	  TI = dp->cbpm_adc_buffer0.raw_data[ block0_wrap_words + block_bunch_tally[tblock] + (turn*block0_bunches) ];
	  BI = dp->cbpm_adc_buffer2.raw_data[ block0_wrap_words + block_bunch_tally[tblock] + (turn*block0_bunches) ];
	  BO = dp->cbpm_adc_buffer4.raw_data[ block0_wrap_words + block_bunch_tally[tblock] + (turn*block0_bunches) ];
	  TO = dp->cbpm_adc_buffer6.raw_data[ block0_wrap_words + block_bunch_tally[tblock] + (turn*block0_bunches) ];
	} else {
	  tblock = 1;
	  TI = dp->cbpm_adc_buffer1.raw_data[ block1_wrap_words + block_bunch_tally[tblock] + (turn*block1_bunches) ];
	  BI = dp->cbpm_adc_buffer3.raw_data[ block1_wrap_words + block_bunch_tally[tblock] + (turn*block1_bunches) ];
	  BO = dp->cbpm_adc_buffer5.raw_data[ block1_wrap_words + block_bunch_tally[tblock] + (turn*block1_bunches) ];
	  TO = dp->cbpm_adc_buffer7.raw_data[ block1_wrap_words + block_bunch_tally[tblock] + (turn*block1_bunches) ];
	}
	phase_word = dp->cbpm_ph_word_buf.ph_words[turn];
      }


      cbpmfio_rw_file_section(fp, fio_mode, 1, (CBPMFIO_FIELD_SPEC*)&(RDV3_raw_data_spec));


      // Move and correct data obtained via the import.
      if (mode == READ) {

	// Store the timing block used to acquire the bunch's turns for later use.
	cbpm_tbt_data[iidx].timing_blocks[bunch] = tblock;

	// Perform data scaling and pedestal subtraction and store values
	// in the instrument's analysis structure.
	dp->cbpm_adc_buffer0.raw_data[count] = TI;
	gsetting = dp->cbpm_op_gain.active_gain_settings[tblock][0];
	cTI = cbpm_correct_value( dp, TI, PED_SUB_SCALED_DATA, gsetting, tblock, 0, 0);
	cbpm_tbt_data[iidx].corrected_0[count] = cTI;

	dp->cbpm_adc_buffer1.raw_data[count] = BI;
	gsetting = dp->cbpm_op_gain.active_gain_settings[tblock][1];
	cBI = cbpm_correct_value( dp, BI, PED_SUB_SCALED_DATA, gsetting, tblock, 1, 0);
	cbpm_tbt_data[iidx].corrected_1[count] = cBI;

	dp->cbpm_adc_buffer2.raw_data[count] = BO;
	gsetting = dp->cbpm_op_gain.active_gain_settings[tblock][2];
	cBO = cbpm_correct_value( dp, BO, PED_SUB_SCALED_DATA, gsetting, tblock, 2, 0);
	cbpm_tbt_data[iidx].corrected_2[count] = cBO;

	dp->cbpm_adc_buffer3.raw_data[count] = TO;
	gsetting = dp->cbpm_op_gain.active_gain_settings[tblock][3];
	cTO = cbpm_correct_value( dp, TO, PED_SUB_SCALED_DATA, gsetting, tblock, 3, 0);
	cbpm_tbt_data[iidx].corrected_3[count] = cTO;

	cbpm_tbt_data[iidx].X_positions[count] =
	  cbpm_compute_pos( iidx, CBPM_HORZ_DIM, cTI, cBI, cBO, cTO );

	cbpm_tbt_data[iidx].Y_positions[count] =
	  cbpm_compute_pos( iidx, CBPM_VERT_DIM, cTI, cBI, cBO, cTO );

	cbpm_tbt_data[iidx].horz_phase_words[turn] = (phase_word >> 19) & 0x000001FF;
	cbpm_tbt_data[iidx].vert_phase_words[turn] = (phase_word >> 10) & 0x000001FF;

	count++;

      } //endif mode


    } //endFOR turn

    block_bunch_tally[tblock]++;

  } //endFOR bunch


  return F_SUCCESS;

}





int cbpm_write_all_raw_data( void ) {
  
  char *func_name = (char *)__FUNCTION__;

  printf("Running %s.\n", func_name);

  if (CTL_System.RunningMode != CBI_MANAGER_MODE) {

    int iidx;
    
    char buf[MAXDATASIZE];    
    char FILENAME_QUERY[CBI_MAX_STRING_LENGTH] = {"FILENAME?"};
    
    FILE *fp;
    char filename[CBI_MAX_STRING_LENGTH]   = {""};
    char full_fname[CBI_MAX_STRING_LENGTH] = {""};
    
    // Wait for filename info from manager, if NULL, then a filename has
    // not yet been generated.  Take this opportunity to do so and send
    // to manager.
    if (CTL_System.RunningMode == CBI_BACKEND_MODE) {
      
      // Send filename request to manager
      printf("Sending filename query...%s\n", FILENAME_QUERY);
      fflush(stdout);
      if(send(CTL_System.mgmt_socket_IDs[0], FILENAME_QUERY, 10, 0) == -1) {
	perror("File_ID send() error");
	fflush(stdout);
	return CBI_F_FAILURE;
      }

      recv(CTL_System.mgmt_socket_IDs[0], full_fname, MAXDATASIZE, 0);
      if ( strcmp( full_fname, "") == 0 ) {
	// Obtain file index # and perform a managed open on file.
	printf("Received empty filename spec.  Generating new filename...   ");
	fflush(stdout);
	fp = cbi_managed_file_open( filename, full_fname, 0, RAW_DIR, RAW, CBI_SINGLE_FILE, FALSE );
	printf("%s\n", full_fname);
	fflush(stdout);
      } else {
	printf("Using pre-existing file... %s\n", full_fname);
	fflush(stdout);
	fp = fopen(full_fname, "a"); // Re-opens, allowing for appending
      }
      
      cbi_sleep(3000);

      printf("Sending full filename back: \"%s\"...\n", full_fname);
      fflush(stdout);
      if(send(CTL_System.mgmt_socket_IDs[0], full_fname, MAXDATASIZE, 0) == -1) {
	perror("File_ID send() error");
	fflush(stdout);
	return CBI_F_FAILURE;
      }
           
    } else {
    
      fp = cbi_managed_file_open( filename, full_fname, 0, RAW_DIR, RAW, CBI_SINGLE_FILE, FALSE );
      printf("Writing data to file %s\n", filename);

    } //endIF RunningMode


    for (iidx = 0; iidx < CTL_System.n_Modules; iidx++) {
      if ( CTL_System.p_Module[iidx]->active == CBI_ACTIVE ) {
	
	cbpm_rw_raw_data( fp, WRITE, iidx );
	
      }
    }
    
    fclose( fp );
    
    
    // If this is a back-end instance, signal the manager when the file
    // write is complete.
    if (CTL_System.RunningMode == CBI_BACKEND_MODE) {
      printf("Sending write completion notice...\n");
      fflush(stdout);
      if(send(CTL_System.mgmt_socket_IDs[0], "FILE WRITE DONE\0", 16, 0) == -1) {
	perror("File_ID send() error");
	fflush(stdout);
	return CBI_F_FAILURE;
      }
    }
  

  } // endIF != CBI_MANAGER_MODE


  return CBI_F_SUCCESS;
  
}
