//-----------------------------------------------------------------------+
// File         :  cbpm_apply_gain_mappings.c                            |
//                                                                       |
// Description  :  Copies gain tables from a gain mapping calibration    |
//                 file generated by an external gain mapping analysis   |
//                 program to respective instruments in an intermediate  |
//                 BPM configuration file in much the same way timing    |
//                 parameters or pedestal tables are saved to an         |
//                 intermediate file prior to installation as master     |
//                 operational parameters.                               |
//                                                                       |
//                 Input file format must be of the form:                |
//                 # comment                                             |
//                 # comment ...                                         |
//                 [BPM_XXY]                                             |
//                 .GAIN_TABLE_0    #.#####  #.##### ...                 |
//                                  #.#####  #.##### ...                 |
//                 .GAIN_TABLE_1    #.#####  #.##### ...                 |
//                                  #.#####  #.##### ...                 |
//                   ...                                                 |
//                                                                       |
// Arguments    :  Master struct array index of the BPM to which this    |
//                 command will be directed.                             |
//                                                                       |
// Author       :  M. Rendina                                            |
//-----------------------------------------------------------------------+

#include "cbpm_includes.h"

#define GAIN_CAL_MAPPING_FILE      "gain_cal_mapping.in"


int cbpm_apply_gain_mappings(void) {
  
  char *func_name = (char *)__FUNCTION__; 
  int debug_level = CTL_System.debug_verbosity;

  FILE *fp_in, *fp_out;
  char filename[CBI_MAX_STRING_LENGTH]   = "";
  char full_fname[CBI_MAX_STRING_LENGTH] = "";
  int status;
  int card, gsetting;
  
  // Instrumnet communication not necessary for this process.
  cbi_close_sockets();


  //-------------------------------------------------
  // Define the list of prompts and their parameters
  //-------------------------------------------------
  int retval, input = FALSE;
  CBI_INIT_PROMPTS(1);
  
  printf("\n\n\n\n");

  char supp_text[CBI_MAX_STRING_LENGTH*3];
  sprintf(supp_text, "Would you like to apply the gain mapping corrections from the file\n"
	  "  ./%s \n"
	  "to existing parameters for all instruments COMMON to the master parameter file\n"
	  "and the gain mapping coefficients input file, and save the result to \n"
	  "an intermediate file?: ", GAIN_CAL_MAPPING_FILE );
  
  char prompt_text[CBI_MAX_STRING_LENGTH];
  sprintf( prompt_text, "(y/n):" );

  int valid_inputs[5] = {4, (int)'y', (int)'Y', (int)'n', (int)'N'};
  int map_out[4]      = {    TRUE,     TRUE,     FALSE,    FALSE};
  prompts[0].supp_text_ptr    = supp_text;
  prompts[0].prompt_text      = prompt_text;
  prompts[0].data_type        = CBI_CHAR;
  prompts[0].valid_inputs     = valid_inputs;
  prompts[0].map_out          = map_out;
  prompts[0].default_value    = 'n';
  prompts[0].destination      = &(input);
  prompts[0].last_val_default = FALSE;


  retval = CBI_PROMPTER();


  if (input == FALSE) {
    printf("\n\nGain mapping corrections not applied.\n");
    return CBI_F_FAILURE;
  }


  fp_in  = fopen(GAIN_CAL_MAPPING_FILE, "r");
  if (fp_in == NULL) {
   sprintf(message, "Cannot open input file: ./%s ", GAIN_CAL_MAPPING_FILE );
   log_message( S_ERROR, func_name, message );
   return CBI_F_FAILURE;
  }

  fp_out = cbi_managed_file_open( filename, full_fname, (int)NULL, PARAMS_DIR, PARAMETERS, CBI_SINGLE_FILE, FALSE );
  if (fp_out == NULL) {
    sprintf(message, "Failure opening instrument parameters file!");
    log_message( S_ERROR, func_name, message );
    return CBI_F_FAILURE;
  }

  cbi_write_param_file_header( fp_out, CTL_System.output_file_index, CBI_FALSE );

  printf("\n\nFilename  : %s\n", filename);
  printf("Full name : %s\n", full_fname);


  // Get list of sections from the input file and the output file
  int insec, outsec, section;
  char infile_sections[FA_MAX_FILE_SECTIONS][FA_MAX_STRING_LENGTH];
  char outfile_sections[FA_MAX_FILE_SECTIONS][FA_MAX_STRING_LENGTH];
  char cull_sections[FA_MAX_FILE_SECTIONS][FA_MAX_STRING_LENGTH];
  
  for (section = 0; section < FA_MAX_FILE_SECTIONS; section++) {
    strcpy(infile_sections[section], "");
    strcpy(outfile_sections[section], "");
    strcpy(cull_sections[section], "");
  }

  // Get the scale factor type from the file's header.
  char scaletype[15];
  int scale_select = 0;
  status = faccess( FA_READ, fp_in, "HEADER", "TYPE", 1, 1, STRING, scaletype );
  rewind(fp_in);

  if (strcmp(scaletype, "MULTIPLICATIVE") == 0) {
    printf("MULTIPLICATIVE type selected.\n");
    scale_select = 1;
  } else if ( strcmp(scaletype, "ABSOLUTE") == 0) {
    printf("ABSOLUTE type selected.\n");
    scale_select = 2;
  } else {
    printf("ERROR!  Scale type is either not present in input file or contains an invalid specification.\n");
    printf("\n\nGain mapping corrections not applied.\n");
    return CBI_F_FAILURE;
  }
  

  printf("Extracting file section order (%s)...\n", GAIN_CAL_MAPPING_FILE);
  fa_extract_section_order(fp_in, infile_sections );



  printf("Extracting file section order (%s)...\n", filename);
  fa_extract_section_order(fp_out, outfile_sections );

  // After reading section order, rewind file.
  rewind(fp_in);
  rewind(fp_out);


  for (outsec = 0; outsec < FA_MAX_FILE_SECTIONS; outsec++) {
    if ( strcmp(outfile_sections[outsec], "") != 0 ) {
      //printf("OUTSEC: %s\n", outfile_sections[outsec] );
    }
  }
  printf("\n\n");
  for (insec = 0; insec < FA_MAX_FILE_SECTIONS; insec++) {
    if ( strcmp(infile_sections[insec], "") != 0 ) {
      //printf("INSEC: %s\n", infile_sections[insec] );
    }
  }

  //----------------------------------------------------------------------------------
  // Cull sections list to those that only appear in BOTH the calibration input file
  // and the output parameter file.
  //
  //   The sections list gets the intersection of the sets of names between the two
  //   files, in the order in which the common ones appear in the OUTPUT file.  It 
  //   can thus be used to control optimized output below.
  //----------------------------------------------------------------------------------
  typedef struct {
    char   section_name[CBI_MAX_STRING_LENGTH];
    float  gain_mapping_factors[CBPM_MAX_TIMING_BLOCKS][CBPM_MAX_CARDS][CBPM_MAX_GAINS];
    float  existing_scale_factors[CBPM_MAX_TIMING_BLOCKS][CBPM_MAX_CARDS][CBPM_MAX_GAINS];
  } INST_GAIN_TABLES;

  

  ////INST_GAIN_TABLES cal_vals[CBI_MAX_INSTRUMENTS];
  INST_GAIN_TABLES cal_vals[FA_MAX_FILE_SECTIONS];

  int inst_count = 0;
  // Initialize section name fields
  for (inst_count = 0; inst_count < CBI_MAX_INSTRUMENTS; inst_count++) {
    strcpy( cal_vals[inst_count].section_name, "" );
  }

  int found_match;
  inst_count = 0;
  for (outsec = 0; outsec < FA_MAX_FILE_SECTIONS; outsec++) {

    if ( strcmp(outfile_sections[outsec], "") != 0 ) {
      found_match = FALSE;
      if (debug_level > CBI_DEBUG_LEVEL_1) {
	printf("OUTSEC: %s\n", outfile_sections[outsec] );
      }

      for (insec = 0; insec < FA_MAX_FILE_SECTIONS; insec++) {
	if ( strcmp(infile_sections[insec], outfile_sections[outsec]) == 0 ) {
	  found_match = TRUE;
	  if (debug_level > CBI_DEBUG_LEVEL_1) {
	    printf("Matched infile: \"%s\"    with outfile: \"%s\"\n", infile_sections[insec], outfile_sections[outsec] );
	  }
	  strcpy( cal_vals[inst_count].section_name, infile_sections[insec] );
	  inst_count++;
	}
      }

      if (!found_match) { 
	printf("Instrument section (outsec=\"%s\") is not common to both files, skipping.\n", outfile_sections[outsec] );
      }

    } //endIF sections[insec] == ""

  } //endFOR outsec

	
	  
  float  gain_map_table[CBPM_MAX_TIMING_BLOCKS][CBPM_MAX_CARDS][CBPM_MAX_GAINS];
  int sec;

  //-----------------------------------------------------------------
  // For each ordered section name in infile list, if it is also in
  // the intersection list, read it in and store in the appropriate 
  // slot of instersection array.
  //-----------------------------------------------------------------
  section = 0;
  int idx = 0;
  while( strcmp( infile_sections[section], "") != 0 ) {

    if (debug_level > CBI_DEBUG_LEVEL_1) {
      printf(" ---- \"%s\" ----\n", infile_sections[section] );
    }

    // Section name is in the intersection list, get the index of the destination to use.
    for (sec = 0; sec < FA_MAX_FILE_SECTIONS; sec++) {
      if ( strcmp(cal_vals[sec].section_name, infile_sections[section]) == 0 ) {
	idx = sec;
	if (debug_level > CBI_DEBUG_LEVEL_1) {
	  printf("BREAK from sec loop.   idx = %d\n", idx);
	}
	break;
      }
    }

    if (debug_level > CBI_DEBUG_LEVEL_1) {
      printf("Reading gain mapping corrections\n");
    }
    status = faccess(FA_READ, fp_in, infile_sections[section], "GAIN_TABLE_0", 4, CBPM_MAX_GAINS, FLOAT, cal_vals[idx].gain_mapping_factors[0] );
    if (debug_level > CBI_DEBUG_LEVEL_1) {
      printf("read status = %d\n", status);
    }
    status = faccess(FA_READ, fp_in, infile_sections[section], "GAIN_TABLE_1", 4, CBPM_MAX_GAINS, FLOAT, cal_vals[idx].gain_mapping_factors[1] );
    if (debug_level > CBI_DEBUG_LEVEL_1) {
      printf("read status = %d\n", status);
    }
    
    section++;
      
  }


  //-----------------------------------------------------------------
  // Do the same thing for the existing scale factor tables from the 
  // outfile.  Central section_name list is in OUTPUT FILE order.  
  //-----------------------------------------------------------------
  section = 0;
  while( strcmp( cal_vals[section].section_name, "") != 0 ) {

    if (debug_level > CBI_DEBUG_LEVEL_1) {
      printf(" ---- \"%s\" ----\n", infile_sections[section] );
      printf("Reading existing scale factors\n");
    }
    status = faccess(FA_READ, fp_out, cal_vals[section].section_name, "GAIN_TABLE_0", 4, CBPM_MAX_GAINS, FLOAT, cal_vals[section].existing_scale_factors[0] );
    if (debug_level > CBI_DEBUG_LEVEL_1) {
      printf("read status = %d\n", status);
    }
    status = faccess(FA_READ, fp_out, cal_vals[section].section_name, "GAIN_TABLE_1", 4, CBPM_MAX_GAINS, FLOAT, cal_vals[section].existing_scale_factors[1] );
    if (debug_level > CBI_DEBUG_LEVEL_1) {
      printf("read status = %d\n", status);
    }

    section++;
      
  }


  // After performing reads for a single instrument, rewind file.
  rewind(fp_in);
  rewind(fp_out);
  
    
  //--------------------------------------------------------------------
  // Apply gain mapping corrections to each existing gain scale factor.
  //   TODO: generalize to higher channel-count devices?
  //--------------------------------------------------------------------
  if (scale_select == 1) {

    printf("\n\nMULTIPLYING existing scale factors by the values provided in gain mapping correction file...\n\n");

    inst_count = 0;
    for (section = 0; section < FA_MAX_FILE_SECTIONS; section++) {
      if (strcmp(outfile_sections[section], "") != 0) {
	
	for (gsetting = 0; gsetting < CBPM_MAX_GAINS; gsetting++) {
	  for (card = 0; card < CBPM_MAX_CARDS; card++) {
	    cal_vals[inst_count].existing_scale_factors[0][card][gsetting] = cal_vals[inst_count].existing_scale_factors[0][card][gsetting] *
	      cal_vals[inst_count].gain_mapping_factors[0][card][gsetting];
	    
	    cal_vals[inst_count].existing_scale_factors[1][card][gsetting] = cal_vals[inst_count].existing_scale_factors[1][card][gsetting] *
	      cal_vals[inst_count].gain_mapping_factors[1][card][gsetting];
	  }
	}
	inst_count++;
	
      }
    }
    
  } //endIF input == 1
  
  
  //------------------------------------------------------------------------
  // Copy in gain mapping corrections as ABSOLUTE scale factors.
  // i.e. DO NOT multiply by the existing factors to reach the final value,
  // just replace the existing factors wholesale.
  //------------------------------------------------------------------------
  int species_select      = -1;
  int gain_setting_select = -1;
  if (scale_select == 2) {

    while (species_select != 0 &&
	   species_select != 1 ) {
      printf("\n\nSelect the SPECIES for which scale factors should be OVERWRITTEN:\n");
      printf("   0 - POSITRONS (GAIN_TABLE_0)\n");
      printf("   1 - ELECTRONS (GAIN_TABLE_1)\n> ");
      fflush(stdout);
      species_select = cbi_get_int_local();
    }
    
    printf("\n\n\n");
    while (gain_setting_select == -1) {
      printf("Select the GAIN SETTING for which scale factors should be OVERWRITTEN:\n");
      printf("      0        |   1 2 3 4 5 6 7 8 9 10\n");
      printf("   Fixed Gain  |       Variable Gain\n> ");
      fflush(stdout);
      gain_setting_select = cbi_get_int_local();
    }

    printf("\n\nREPLACING existing scale factors with the values provided in gain mapping correction file...\n\n");
    fflush(stdout);

    inst_count = 0;
    for (section = 0; section < FA_MAX_FILE_SECTIONS; section++) {
      if (strcmp(outfile_sections[section], "") != 0) {
	
	for (gsetting = 0; gsetting < CBPM_MAX_GAINS; gsetting++) {
	  for (card = 0; card < CBPM_MAX_CARDS; card++) {
	    if (gsetting == gain_setting_select){
	      cal_vals[inst_count].existing_scale_factors[species_select][card][gsetting] = 
		cal_vals[inst_count].gain_mapping_factors[species_select][card][gsetting];
	    }
	  }
	}
	inst_count++;
	
      }
    }
    
  } //endIF input == 2
  
  

  // central section_name list is in OUTPUT FILE order.
  section = 0;
  while( strcmp( cal_vals[section].section_name, "") != 0 ) {

    // Section open
    if (debug_level > CBI_DEBUG_LEVEL_1) {
      printf("Accessing file section >%s<\n", cal_vals[section].section_name);
    }
    faccess( FA_WRITE, fp_out, cal_vals[section].section_name, NULL, 0, 0, 0, NULL);

    if (debug_level > CBI_DEBUG_LEVEL_1) {
      printf("Writing tables for section [%s]...\n", cal_vals[section].section_name);
    }
    status = faccess(FA_WRITE, fp_out, cal_vals[section].section_name, "GAIN_TABLE_0", 4, CBPM_MAX_GAINS, FLOAT, cal_vals[section].existing_scale_factors[0] );
    if (debug_level > CBI_DEBUG_LEVEL_1) {
      printf("write status = %d\n", status);
    }
    status = faccess(FA_WRITE, fp_out, cal_vals[section].section_name, "GAIN_TABLE_1", 4, CBPM_MAX_GAINS, FLOAT, cal_vals[section].existing_scale_factors[1] );
    if (debug_level > CBI_DEBUG_LEVEL_1) {
      printf("write status = %d\n", status);
    }

    section++;
  }


  printf("Stopping faccess() session...\n");
  faccess( FA_WRITE, fp_out, NULL, NULL, 0, 0, 0, NULL);


  if( fclose(fp_in) != 0) {
    perror("fclose: ");
  }
  if( fclose(fp_out) != 0) {
    perror("fclose: ");
  }

  printf("\nWrote file : %s\n", full_fname);


  return CBI_F_SUCCESS;

}

